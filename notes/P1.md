---
title: Letný semester, prednáška č. 1
---

* TOC
{:toc}

## Úvodné informácie

### Kontakt na vyučujúcich predmetu

  - Rovnaká stránka predmetu ako v zimnom semestri:
    <https://compbio.fmph.uniba.sk/vyuka/prog/>.
  - Mailové adresy a čísla kancelárií vyučujúcich možno nájsť na
    [hlavnej stránke](Programovanie_\(2\)_v_Jave "wikilink") tohto
    predmetu.
  - **Hromadná mailová adresa zo zimného semestra v letnom semestri
    nefunguje**.
  - Konzultácie po predchádzajúcej dohode mailom.

### Testovač

  - Na cvičeniach sa bude používať rovnaký
    [testovač](https://prog.dcs.fmph.uniba.sk/) ako v zimnom semestri.
  - Heslo na testovači: rovnaké ako v minulom semestri resp. minulý rok;
    u prípadných nových používateľov nastavené na `prog2`.
  - V prípade problémov s prihlasovaním dajte vedieť.

### Priebeh semestra

  - Predmet sa bude riadiť [pravidlami pre letný
    semester](./Pravidla.md).
  - Okrem testov a domácich úloh budú na testovači zverejňované aj
    nebodované cvičenia, ktorých riešenie je silne odporúčané.

### Softvér potrebný na tomto predmete

  - Java SE 23 (prípadne ľubovoľná verzia od 11 vyššie). Na testovači
    beží dlhodobo podporovaná Java 21; rozdiel medzi oboma verziami je
    minimálny.
  - Platforma JavaFX pre vývoj aplikácií s grafickým používateľským
    rozhraním.
  - Vývojové prostredie (IDE) pre Javu, odporúčame IntelliJ IDEA
    Community Edition.
  - [Informácie o inštalácii a základnom použití uvedeného
    softvéru](./Softver.md).
  - Vhodnou príležitosťou na vyriešenie prípadných problémov môžu byť
    prvé cvičenia.

### Zdroje informácií o jazyku Java

  - [Dokumentácia k Java
    API](https://docs.oracle.com/en/java/javase/23/docs/api/index.html).
  - [Tutoriály k jazyku Java](https://docs.oracle.com/javase/tutorial/).

## Základné črty jazyka Java a programovania v ňom

Prvoradým cieľom tohto predmetu je zvládnutie základov *objektovo
orientovaného programovania* (OOP) prostredníctvom programovacieho
jazyka Java. Na úvod je užitočné vedieť o tomto jazyku nasledujúce:

  - Základné syntaktické konštrukcie jazyka Java sú v mnohom veľmi
    podobné jazykom C a C++. Už tento týždeň by sme mali zvládnuť
    prepísať do Javy väčšiu časť programov z minulého semestra; budúci
    týždeň by to už mali byť úplne všetky programy.
  - Jazyk Java je silne (aj keď nie čisto) *objektovo orientovaný*.
    Použite *tried* – ktoré sú popri *objektoch* základným konceptom
    OOP – je nutné na napísanie aj toho najjednoduchšieho programu.
  - Na druhej strane je triedu možné použiť aj ako obyčajný „obal” pre
    niekoľko *metód* (t. j. funkcií) podobného typu ako v minulom
    semestri. Takýmto spôsobom budeme s Javou pracovať na dnešnej
    prednáške. S ozajstným objektovo orientovaným programovaním
    začneme až budúci týždeň.
  - Programy v jazyku Java sa obvykle nekompilujú do strojového kódu,
    ale do tzv. javovského *bytekódu*. Po skompilovaní programu teda
    nedostávame bežný spustiteľný súbor, ale súbor, ktorý možno spustiť
    na javovskom virtuálnom stroji (angl. *Java Virtual Machine*; skr.
    JVM). Vykonávanie takýchto programov je síce o niečo pomalšie, zato
    sú však prenositeľné medzi rôznymi operačnými systémami a
    architektúrami.

Celkovo ide o jazyk omnoho vyššej úrovne, než jazyk C: v oveľa väčšej
miere sa tu abstrahuje od počítačovej architektúry. Java napríklad
neumožňuje priamy prístup k pamäťi počítača a o uvoľňovanie alokovanej
pamäte sa stará JVM automaticky prostrednictvom mechanizmu tzv. *garbage
collection*. Hoci teda jazyk nie je príliš vhodný na nízkoúrovňové
programovanie, tvorba „bežných” používateľských programov je tu
podstatne pohodlnejšia, než napríklad v jazyku C. Okrem toho Java
disponuje veľkou knižnicou štandardných tried (*Java Class Library*;
skr. JCL), v ktorej je okrem iného implementované aj množštvo algoritmov
a dátových štruktúr. Orientáciu v možnostiach ponúkaných touto knižnicou
značne uľahčuje [dokumentácia k
nej](https://docs.oracle.com/en/java/javase/23/docs/api/index.html).

Rozdiel v úrovni abstrakcie medzi jazykmi C a Java sa premieta aj do
typického programátorského štýlu. Od efektívnosti samotnej implementácie
sa dôraz obvykle posúva k aspektom softvérového inžinierstva, ako sú
napríklad čitateľnosť, rozšíriteľnosť a „spravovateľnosť” kódu. S
niektorými elementárnymi princípmi softvérového inžinierstva sa
zoznámime aj na tomto predmete.

## Prvý program v jazyku Java

Tradične začneme programom, ktorý na konzolu vypíše text `Hello,
World!`.

``` java
public class Hello {

    public static void main(String[] args) {
        System.out.println("Hello, World!");
    }

}
```

  - Názov súboru sa musí zhodovať s názvom triedy, ku ktorému sa pridá
    prípona `.java` – v našom prípade teda musí byť zdrojový kód uložený
    v súbore `Hello.java`.
  - Program je potrebné skompilovať javovským kompilátorom a následne
    spustiť na javovskom virtuálnom stroji – návod možno nájsť na
    [osobitnej stránke](./Softver.md). Po
    skompilovaní programu získame súbor `java.class` spustiteľný na JVM.

Rozoberme postupne jednotlivé časti uvedeného programu:

  - Metóda (funkcia) `main`, ktorá sa podobne ako v C/C++ začne
    vykonávať bezprostredne po spustení programu, je „obalená” v
    triede, ktorú sme nazvali `Hello`. V jazyku Java musí byť všetok kód
    súčasťou nejakej triedy (význam tried pre OOP zatiaľ ponechajme
    bokom).
  - Hlavička metódy `main` musí byť vždy tvaru ako vyššie. Modifikátory
    `public` a `static` si vysvetlíme neskôr; nasleduje návratový typ
    `void`, názov metódy `main` a argument tejto metódy, ktorým sú
    argumenty programu z príkazového riadku (v podobe poľa reťazcov).
  - Samotný výpis na konzolu realizuje metóda `System.out.println`.

Keďže jeden väčší program typicky pozostáva z množstva rôznych tried (v
rôznych súboroch), je možné triedy ďalej umiestniť do balíkov; program
tak často pozostáva z niekoľkých balíkov navzájom súvisiacich tried.
Umiestnenie triedy do balíka možno realizovať príkazom na začiatku
zdrojového súboru.

``` java
package somepackage;

public class Hello {

    public static void main(String[] args) {
        System.out.println("Hello, World!");
    }

}
```

  - V našom prípade sme triedu `Hello` umiestnili do balíka
    `somepackage`. Pri práci s IDE ako napr. IntelliJ je často potrebné
    pridať balík aj do projektu; rozdiel je tiež pri kompilovaní a
    spúšťaní triedy z príkazového riadku. Viac sa možno dočítať
    [tu](./Softver.md).
  - Pokiaľ deklarácia balíka chýba, považuje sa trieda za súčasť
    nepomenovaného balíka (angl. *unnamed package* alebo *default
    package*). Používanie nepomenovaného balíka vo všeobecnosti nie je
    dobrá prax, ale je zmysluplné pri menších programoch pre vlastnú
    potrebu (alebo pre potreby tohto predmetu).
  - Za dobrú prax sa naopak považuje pomenúvanie balíkov tak, aby boli
    celosvetovo jednoznačne identifikovateľné – za týmto účelom preto
    boli vybracované [špeciálne
    konvencie](https://docs.oracle.com/javase/tutorial/java/package/namingpkgs.html),
    ktoré ale na tomto predmete nebudeme dodržiavať.

## Konvencie pomenúvania identifikátorov

Za účelom sprehľadnenia zdrojového kódu a často pomerne rozsiahlych
knižníc sa pri pomenúvaní identifikátorov v Jave používajú (okrem iných
aj) nasledujúce konvencie:

  - Názvy tried by mali vždy začínať veľkým písmenom (pri viacslovných
    názvoch začína veľkým písmenom aj každé ďalšie slovo).
  - Názvy premenných a metód by naopak mali vždy začínať malým písmenom
    (pri viacslovných názvoch začínajú ďalšie slová veľkým písmenom).

Nedodržiavanie týchto konvencií budeme na tomto predmete považovať za
chybu. O ďalších konvenciách používaných v tomto smere sa možno dočítať
[tu](https://www.oracle.com/java/technologies/javase/codeconventions-namingconventions.html).

## Príklad o niečo rozsiahlejšieho programu

Nižšie je príklad o niečo rozsiahlejšieho programu v jazyku Java.
Pokúste sa s využitím skúseností z minulého semestra uhádnuť, čo tento
program robí.

``` java
import java.util.*;

public class Program {

    /* Spocita sucet prvkov pola a.
     */
    public static int sum(int[] a) {
        int result = 0;
        for (int i = 0; i <= a.length - 1; i++) {
            result += a[i];
        }
        return result;
    }

    /* Spocita priemer hodnot prvkov pola a.
     */
    public static double average(int[] a) {
        return (double) sum(a) / a.length;
    }

    /* Najde najvacsi prvok pola a.
     */
    public static int max(int[] a) {
        int max = Integer.MIN_VALUE;  // Premenna ma rovnaky nazov ako metoda
        for (int i = 0; i <= a.length - 1; i++) {
            if (a[i] >= max) {
                max = a[i];
            }
        }
        return max;
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        int n = scanner.nextInt();
        int[] a = new int[n];

        for (int i = 0; i <= n - 1; i++) {
            a[i] = scanner.nextInt();
        }

        System.out.println("Sucet: " + sum(a));
        System.out.println("Priemer: " + average(a));
        System.out.println("Maximum: " + max(a));
    }

}
```

  - Okamžite vidieť množstvo podobností medzi jazykmi C/C++ a Java, ale
    aj niekoľko drobných rozdielov.
  - Konštrukcie jazyka Java použité v tomto programe podrobnejšie
    rozoberieme nižšie.

## Základné konštrukcie jazyka Java

### Primitívne typy

Jazyk Java podporuje celkovo osem [primitívnych dátových
typov](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html)
(`void` sa za primitívny typ nepovažuje):

  - `int`: 32-bitové celé čísla so znamienkom, v rozsahu od
    *-2<sup>31</sup>* po *2<sup>31</sup> - 1*; ďalšie celočíselné typy
    sú `byte`, `short` a `long` (na rozdiel od C/C++ už teda `long` a
    `short` nie sú modifikátory, ale priamo celočíselné typy).
  - `double`: 64-bitové desatinné čísla s pohyblivou desatinnou čiarkou;
    ďalší typ desatinných čísel je 32-bitový `float`.
  - `boolean`: logické hodnoty `true` alebo `false`.
  - `char`: 16-bitové znaky v kódovaní Unicode (UTF-16); typ teda
    napríklad podporuje slovenskú diakritiku.

Deklarácie premenných a priradenia zapisujeme rovnako ako v C/C++. Na
rozdiel od C/C++ možno napríklad definovať aj lokálnu premennú s
rovnakým názvom ako niektorá metóda.

``` java
int x = 0;
```

Kompilátor pritom nedovolí použitie neinicializovanej lokálnej
premennej.

``` java
int x;
System.out.println(x); // variable x might not have been initialized
```

Neskôr uvidíme, že prvky polí a premenné tried a ich inštancií sa
inicializujú automaticky.

Pretypovanie tiež funguje podobne ako v C/C++, avšak implicitné
(automatické) pretypovanie je možné pre menší počet dvojíc typov, než v
C/C++. Číselné typy možno usporiadať ako `byte ≺ short ≺ int ≺ long ≺
float ≺ double` a implicitné pretypovanie je možné iba v smere tohto
usporiadania. Ďalej je možné implicitne pretypovať `char` na `int`,
`long`, `float` a `double` (nie však naopak). Zvyšné pretypovania je
nutné robiť explicitne, rovnako ako v C/C++.

``` java
int x = 65;
char c = (char) x;
System.out.println(c);
```

Možno ale napríklad priamo písať `char c = 65`.

### Operátory

Jazyk Java podporuje podobnú sadu operátorov ako jazyky C a C++; ich
kompletný zoznam vrátanie precedencií možno nájsť
[tu](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/operators.html).
Spomeňme predovšetkým:

  - Operátory priradenia `=, +=, *=`, atď.
  - Aritmetické operátory `+, -, *, /, %`. Na celočíselných typoch sa
    operátor `/` správa, rovnako ako v C/C++, ako celočíselné delenie.
  - Prefixové a sufixové operátory `++, --`.
  - Relačné a porovnávacie operátory `==, !=, <, >, <=, >=`.
  - Logické operátory `||, &&, !`.

### Cykly a podmienky

Nasledujúce konštrukcie sú v Jave veľmi podobné ako v C/C++:

  - Podmienky: `if`, `else` a `switch`.
  - Cykly: `for`, `while`, `do ... while`.
  - Príkazy `break` a `continue`.

Drobný rozdiel pri ich použití vyplýva zo skutočnosti, že v Jave
nedochádza k automatickému pretypovaniu z napr. číselných typov na
`boolean`. Napríklad nasledujúci kus kódu, ktorý by bol v C/C++
korektný, vyústi v Jave chybu.

``` java
int n = 1;
if (n) {  // incompatible types: int cannot be converted to boolean
    // ...           
}
```

Nápravu dosiahneme nahradením celočíselného výrazu `n` výrazom logickým.

``` java
int n = 1;
if (n != 0) {
    // ...           
}
```

### Jednorozmerné polia

V Jave sa oproti C/C++ používa trochu iná syntax pre deklaráciu poľa.

``` java
int[] a; // Deklaracia premennej a reprezentujucej pole celych cisel
```

Samotné vytvorenie poľa a priradenie referencie naň do premennej `a`
následne možno realizovať podobne ako pri dynamicky alokovaných poliach
v C++.

``` java
a = new int[10]; 
```

Pamäť alokovanú pri vytvorení poľa nie je potrebné manuálne uvoľňovať;
stará sa o to automatický „smetiarsky” mechanizmus (angl. *garbage
collection*). Prípadne tiež možno spojiť deklaráciu premennej s
vytvorením poľa do jediného príkazu.

``` java
int[] a = new int[rozsah]; 
```

Namiesto `int[] a` možno písať aj `int a[]`; prvý spôsob je ale
prirodzenejší, keďže typom premennej `a` je v oboch prípadoch `int[]`.

Pri vytvorení poľa sa všetky jeho prvky automaticky inicializujú – a to
na 0 pri poliach čísel resp. znakov (kde ide o znak s kódom 0, nie o
znak '0'), na `false` pri poliach booleovských hodnôt a na `null` pri
poliach objektov a polí (poľami takéhoto typu sa budeme zaoberať až
neskôr). V prípade potreby inicializovať pole vopred známej dĺžky na
iné hodnoty možno použiť nasledujúcu skratku.

``` java
int[] a = {0, 1, 2, 3, 4, 5}; 
```

Týmto príkazom sa do premennej `a` priradí referencia na šesťprvkové
pole obsahujúce postupne hodnoty `0, 1, 2, 3, 4, 5`. Takéto priradenie
možno realizovať *iba v rámci príkazu, v ktorom je príslušná premenná aj
deklarovaná*. Neskôr možno do premennej `a` priradiť takto „vymenované”
pole nasledovne.

``` java
int[] a;

// ...

a = new int[]{0, 1, 2, 3, 4, 5}; 
```

Súčasťou poľa je v Jave aj informácia o jeho dĺžke, ku ktorej možno pre
pole `a` pristúpiť cez `a.length`. Nasledujúci kus kódu tak napríklad do
stoprvkového poľa `a` uloží postupnosť čísel `0, 1, 2, ..., 99`.

``` java
int[] a = new int[100];
for (int i = 0; i <= a.length - 1; i++) {
    a[i] = i;
}
```

V prípade pokusu o prístup k prvku poľa mimo jeho rozsah Java za behu
programu vyhodí výnimku `java.lang.ArrayIndexOutOfBoundsException`.
Mechanizmom výnimiek a ich spracovaním sa na tomto predmete budeme
zaoberať neskôr; v tomto momente je podstatná skutočnosť, že v Jave nie
je možné pomocou prístupu k danému poľu prepísať pamäť mimo jeho rozsahu
– čo je jedna z najnepríjemnejších chýb v C/C++.

### Hodnoty vs. referencie v jazyku Java

Napriek tomu, že v jazyku Java neexistuje mechanizmus smerníkov, ani
žiadna obdoba smerníkovej aritmetiky, všetky premenné okrem premenných
primitívnych typov obsahujú referencie predstavujúce adresy v pamäti.
Presnejšie:

  - Premenné primitívnych typov obsahujú *hodnoty* týchto primitívnych
    typov.
  - Premenné všetkých zvyšných typov obsahujú *referencie* na pole alebo
    na objekt (aj polia sú v skutočnosti veľmi špeciálne objekty, ale to
    teraz ponechajme bokom).

Premenné obsahujúce referencie – zatiaľ vieme pracovať iba s premennými
ukazujúcimi na pole – sa tak správajú veľmi podobne ako smerníky v
C/C++. Operátor `=` aplikovaný na takéto premenné nekopíruje hodnoty,
ale referencie; podobne operátor `==` neporovnáva hodnoty, ale
referencie.

``` java
int[] a = {1, 2, 3, 4, 5};
int[] b = a;                   // Premenne a, b ukazuju na to iste patprvkove pole
b[0] = 10;
System.out.println(a[0]);      // Vypise 10
b = new int[a.length];         // Premenne a, b uz teraz ukazuju na dve rozne polia
for (int i = 0; i <= b.length - 1; i++) {
    b[i] = a[i];               // Hodnoty v oboch poliach su odteraz rovnake, polia ako take su rozne
}
System.out.println(a == b);    // Vypise false
```

Premenná obsahujúca referenciu môže nadobúdať špeciálnu hodnotu `null`;
v takom prípade referencia neukazuje na žiaden kus pamäte.

### Cyklus `for each`

V Jave existuje špeciálny variant cyklu `for`, tzv. cyklus `for each`,
umožňujúci postupne prejsť cez všetky hodnoty prvkov poľa `a` aj bez
indexovej premennej. Napríklad kus kódu

``` java
int[] a = {6, 5, 4, 3, 2, 1};
for (int x : a) {
    System.out.println(x);
}
```

je ekvivalentný nasledujúcemu kódu.

``` java
int[] a = {6, 5, 4, 3, 2, 1};
for (int i = 0; i <= a.length - 1; i++) {
    System.out.println(a[i]);
}
```

Vo všeobecnosti možno povedať, že cyklus `for each` s iteračnou
premennou `x` pracuje nasledovne:

  - Prechádza postupne pole od začiatku po jeho koniec.
  - V každej iterácii najprv skopíruje hodnotu na danej pozícii poľa do
    premennej `x` a následne vykoná príkazy v tele cyklu.

Z toho vyplýva, že *pomocou cyklu `for each` nemožno meniť hodnoty
prechádzaného poľa.* Napríklad v cykle

``` java
for (int x : a) {
    x = 0;
}
```

sa nemenia jednotlivé prvky poľa, ale iba lokálna premenná `x`. Avšak v
prípade, že sú prvkami poľa referencie, možno pomocou cyklu `for each`
meniť hodnoty, na ktoré tieto referencie ukazujú (to je vlastnosť, ktorú
oceníme až neskôr).

### Viacrozmerné polia

Popri jednorozmerných poliach možno v Jave pracovať aj s dvojrozmernými
poľami, ktoré sa správajú podobne ako polia smerníkov resp. smerníky na
smerníky v C/C++. V javovskej terminológii môžeme povedať, že
dvojrozmerné pole je poľom polí. Obdĺžnikové pole vytvoríme napríklad
nasledovne.

``` java
int[][] a = new int[3][4];  // Vytvori pole s troma riadkami a styrmi stĺpcami
```

Takéto pole si možno predstaviť ako trojprvkové pole jednorozmerných
polí dĺžky 4. Napríklad `a[0]` je teda jednorozmerné pole zodpovedajúce
nultému riadku dvojrozmerného poľa `a`. S dvojrozmerným poľom potom
pracujeme prirodzeným spôsobom.

``` java
for (int i = 0; i <= a.length - 1; i++) {
    for (int j = 0; j <= a[i].length - 1; j++) {
        a[i][j] = i + j;
    }
}
```

Výsledné pole je znázornené na nasledujúcom obrázku.

{% include figure.html src="JPamat1.png" caption="" %}

Alternatívne možno najprv pamäť alokovať iba pre pole jednotlivých
riadkov a následne pre každý z riadkov zvlášť. Takto môžeme vytvoriť aj
iné ako obdĺžnikové polia, napríklad „trojuholník” z nasledujúceho
príkladu.

``` java
int[][] a = new int[3][]; // V tomto momente su a[0], a[1] aj a[2] rovne null (vdaka automatickej inicializacii prvkov pola)
for (int i = 0; i <= a.length - 1; i++) {
    a[i] = new int[i + 1];
}
for (int i = 0; i <= a.length - 1; i++) {
    for (int j = 0; j <= a[i].length - 1; j++) {
        a[i][j] = j;
    }
}
```

Výsledné pole je znázornené na nasledujúcom obrázku.

{% include figure.html src="JPamat2.png" caption="" %}

Z tejto predstavy o reprezentácii dvojrozmerných polí by malo byť
zrejmé, že napríklad príkaz `int[][] a = new int[][10];` nie je
korektný.

Rovnako ako s dvojrozmernými poľami možno v Jave pracovať aj s poľami o
ľubovoľnom konečnom počte rozmerov. Pri alokovaní takýchto polí platí,
že je potrebné určiť *prvých niekoľko* rozmerov (kde „niekoľko” v tomto
prípade znamená „aspoň jeden”).

``` java
int[][][] a = new int[3][4][5]; // OK
int[][][] b = new int[3][4][];  // OK
int[][][] c = new int[3][][];   // OK
int[][][] d = new int[][4][5];  // Chyba
int[][][] e = new int[3][][5];  // Chyba
int[][][] f = new int[][][];    // Chyba
```

## Statické metódy

Obdobou funkcií, ako ich poznáme z minulého semestra, sú v jazyku Java
*statické metódy* triedy.

  - Definujú sa vždy vo vnútri nejakej triedy s použitím podobnej
    syntaxe ako v C/C++. Pred návratový typ je potrebné napísať kľúčové
    slovo `static`, vďaka ktorému pôjde o *statickú* metódu triedy –
    čiže zjednodušene povedané „obyčajnú funkciu” – a nie o metódu
    inštancie triedy, čo je koncept objektovo orientovaného
    programovania, s ktorým sa zoznámime na budúcej prednáške.
  - Pred klúčové slovo `static` ešte možno pridať *modifikátor prístupu*
    ako napr. `public` alebo `private` hovoriaci o viditeľnosti metódy z
    iných tried a balíkov. Modifikátormi prístupu sa budeme detailnejšie
    zaoberať neskôr.
  - Statické metódy voláme rovnako ako funkcie v C/C++ (pri statickej
    metóde `metoda` z inej triedy `Trieda` pri jej volaní píšeme
    `Trieda.metoda`). Kľúčové slovo `return` sa tiež správa podobne ako
    v C/C++, avšak program obsahujúci metódu s návratovým typom rôznym
    od `void` a chýbajúcim príkazom `return` nie je možné skompilovať.
    Rovnako ako v C/C++ funguje aj rekurzia.

*Príklad*:

``` java
public class Trieda {

    static long faktorial(int n) {
        if (n == 0) {
            return 1;
        } else {
            return n * faktorial(n - 1);
        }
    }

    public static void main(String[] args) {
        System.out.println(faktorial(18));
    }
}
```

### Metóda `main`

  - Špeciálnou statickou metódou je metóda `main`, ktorá sa vykoná
    bezprostredne po spustení programu (presnejšie danej triedy). Tá
    musí mať návratový typ `void`, modifikátor prístupu `public` a
    jediný argument typu `String[]` reprezentujúci pole argumentov
    programu z príkazového riadku. Prípadné metódy `main` s inou
    hlavičkou sa považujú za „obyčajné” metódy a po spustení programu
    sa nevykonávajú.

<!-- end list -->

``` java
public class Trieda {

    public static void main() {
        System.out.println("Tento text sa nikdy nevypise.");
    }

    public static void main(String[] args) {
        System.out.println("Pocet argumentov: " + args.length);
    }
}
```

  - Každá trieda, od ktorej po skompilovaní očakávame spustiteľnosť na
    JVM, musí mať definovanú hlavnú metódu `main`; často však píšeme aj
    triedy, ktoré slúžia len na použitie z iných tried.
  - V IDE ako napr. IntelliJ je zvyčajne potrebné vybrať hlavnú triedu
    projektu, čo je trieda, ktorú sa prostredie bude snažiť spúšťať po
    spustení celého projektu. Táto trieda tak musí mať definovanú metódu
    `main`.

### Predávanie argumentov metód

Argumenty metód sa v jazyku Java *vždy predávajú hodnotou*.

  - Pre argumenty sa tedy vždy vytvoria nové lokálne premenné, do
    ktorých sa skopírujú hodnoty argumentov, s ktorými bola metóda
    volaná.
  - *Nie je teda možné napísať metódu, ktorá pozmení premenné z
    volajúcej metódy*. Ak sú ale argumentmi metódy referencie (polia
    alebo objekty), je možné pozmeniť hodnoty, na ktoré táto referencia
    ukazuje (t. j. napríklad zmeniť obsah poľa alebo premenné objektu).

*Príklad*:

``` java
public class Trieda {

    static void f(int n, int[] a) {
        n = 6;
        a[0] = 7;
        a = new int[]{8, 9, 10, 11, 12};
    }

    public static void main(String[] args) {
        int n = 0;
        int[] a = {1, 2, 3, 4, 5};
        f(n, a);
        System.out.println(n);     // Vypise 0
        System.out.println(a[0]);  // Vypise 7
    }
}
```

  - Špeciálne napríklad v Jave nie je možné napísať metódu `swap`, ktorá
    vymení hodnoty dvoch premenných primitívnych typov.

## Práca s reťazcami

Zvyšok tejto prednášky sčasti presahuje jej rámec tým, že začneme
pracovať s niektorými špeciálnymi objektmi bez toho, aby sme si
vysvetlili mechanizmus objektov vo všeobecnosti. Už pomerne elementárne
úkony, ako práca s reťazcami alebo so vstupom a výstupom, sa totiž v
Jave realizujú s využitím objektov. Nasledujúce pasáže sú motivované
praktickou potrebou zvládnutia týchto úkonov; hlbšie pochopenie tohto
materiálu nadobudneme budúci týždeň.

### Trieda `String`

Reťazce znakov sú v Jave objektmi triedy
[`String`](https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/lang/String.html).
Premenné typu `String` teda majú charakter referencií na samotný objekt.
Objekty triedy `String` sú nemodifikovateľné reťazce – po vytvorení ich
už teda nemožno meniť. Premennú typu `String` ale samozrejme môžeme
meniť tak, že do nej priradíme referenciu na iný objekt typu `String`.

  - Text ohraničený úvodzovkami sa považuje za reťazec typu `String`.
  - Operátor `+` realizuje zreťazenie reťazcov. Stačí dokonca, aby bol
    aspoň jeden z operandov reťazec, zvyšné sa na `String` skonvertujú
    automaticky.

*Príklad*:

``` java
String s = "Hello, World!";
System.out.println(s);

int n = 42;
s = "Hodnota premennej n je " + n + ".";
System.out.println(s);
```

Keďže sú premenné typu `String` referenciami na objekt, operátor `=`
tiež kopíruje iba referencie a operátor `==` neporovnáva hodnoty
reťazcov (t. j. samotné texty), ale adresy v pamäti. Vzhľadom na
konštantnosť reťazcov je tu častejším zdrojom chýb nesprávne použitie
operátora `==`. Porovnanie reťazcov správne realizuje metóda
\[<https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/lang/String.html#equals(java.lang.Object>)
`equals`\].

``` java
String str1 = "nejaky text";
String str2 = str1;             // str2 a str1 ukazuju na to iste miesto v pamati
String str3 = str1 + "";        // str3 a str1 ukazuju na rozne miesta v pamati, ktore obsahuju rovnake retazce
String str4 = new String(str1); // str4 a str1 ukazuju na rozne miesta v pamati, ktore obsahuju rovnake retazce
if (str2 == str1) {
    System.out.println("str2 == str1");
}
if (str3 == str1) {
    System.out.println("str3 == str1");
}
if (str4 == str1) {
    System.out.println("str4 == str1");
}
if (str2.equals(str1)) {
    System.out.println("str2.equals(str1)");
}
if (str3.equals(str1)) {
    System.out.println("str3.equals(str1)");
}
if (str4.equals(str1)) {
    System.out.println("str4.equals(str1)");
}
```

V Jave možno `switch` aplikovať aj na reťazce.

``` java
String s;
int n;

// ...

switch (s) {
    case "ano":
        n = 1;
        break;
    case "nie":
        n = 0;
        break;
    default:
        n = -1;
}
```

Z ďalších metód triedy `String`, ktoré možno použiť na manipuláciu s
reťazcami, spomeňme aspoň tieto:

  - Metóda
    \[<https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/lang/String.html#length>()
    `length`\] vráti dĺžku daného reťazca. *Pozor*: keďže ide o metódu
    (bez argumentov), na rozdiel od polí pre reťazec `s` píšeme
    `s.length()` so zátvorkami na konci.
  - Metóda
    [`charAt`](https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/lang/String.html#charAt\(int\))
    s jedným celočíselným argumentom vráti znak na danej pozícii.

<!-- end list -->

``` java
String s = "retazec";
for (int i = 0; i <= s.length() - 1; i++) {
    System.out.println(s.charAt(i));
}
```

  - Množstvo ďalších metód na prácu s reťazcami možno nájsť v
    [dokumentácii k triede
    `String`](https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/lang/String.html).

### Trieda `StringBuilder`

V prípade nutnosti daný reťazec často modifikovať je použitie triedy
`String` pomerne pomalé, pretože pri každej modifikácii reťazca je
potrebné vytvoriť nový objekt. Rýchlejšou alternatívou je použitie
triedy
[`StringBuilder`](https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/lang/StringBuilder.html)
reprezentujúcej *modifikovateľný* reťazec, ktorý je tiež konvertovateľný
na `String`.

Napríklad reťazec `abc...z` obsahujúci všetky písmená malej anglickej
abecedy tak môžeme vytvoriť dvoma rôznymi spôsobmi: buď pomocou pomalého
vytvárania 27 rôznych objektov triedy `String`

``` java
String abeceda = "";
for (char c = 'a'; c <= 'z'; c++) {
    abeceda = abeceda + c;  
}
```

alebo pomocou rýchlejšieho vytvorenia jedného objektu typu
`StringBuilder`, jeho postupných modifikácií a následného vytvorenia
jedného objektu typu `String`.

``` java
StringBuilder buffer = new StringBuilder();
for (char c = 'a'; c <= 'z'; c++) {
     buffer.append(c);  
}
String abeceda = buffer.toString();  
```

Reťazec reprezentovaný objektom typu `StringBuilder` môžeme aj priamo
vypísať na konzolu.

``` java
System.out.println(buffer);
```

Naopak v prípadoch, keď reťazec nie je potrebné modifikovať, je
implementácia cez `String` o niečo efektívnejšia.

## Vstup a výstup

Zameriame sa teraz na základy práce s textovým vstupom a výstupom – či
už na konzole, alebo v podobe textových súborov.

### Výstupné prúdy: trieda `PrintStream`

Textový výstup možno v Jave najjednoduchšie produkovať pomocou triedy
[`PrintStream`](https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/io/PrintStream.html),
ktorú je nutné importovať z balíka `java.io`; prípadne je možné
importovať aj kompletný balík `java.io`.

``` java
import java.io.*; // alebo: import java.io.PrintStream;

public class Trieda {
    
    public static void main(String[] args) {
        // ...
    }
}
```

Výstupný prúd pre zápis do textového súboru `vystup.txt` vytvoríme
napríklad nasledovne.

``` java
PrintStream out = new PrintStream("vystup.txt");
```

  - V prípade, že súbor `vystup.txt` existuje, premaže sa týmto volaním
    jeho obsah; v prípade potreby zapisovať na koniec existujúceho
    súboru možno použiť `PrintStream out = new PrintStream(new
    FileOutputStream("vystup.txt", true))`, kde o pridávaní na koniec
    súboru hovorí booleovský parameter `true` (viac v dokumentácii).
  - Adresár, od ktorého sa počíta takáto relatívna adresa súboru, závisí
    od prostredia. Pri spúšťaní programu z príkazového riadku sa súbor
    `vystup.txt` vytvorí v adresári, z ktorého bol spustený interpreter
    `java`. Pri práci s IntelliJ ide pri východzích nastaveniach o
    koreňový adresár projektu (obsahujúci podadresáre ako `src` a
    `out`).
  - Vytvorenie inštancie triedy `PrintStream` môže spôsobiť výnimku typu
    `IOException`, ktorú je nutné ošetriť. Spracovaním výnimiek sa na
    tomto predmete budeme zaoberať až neskôr – zatiaľ teda zvolíme
    najjednoduchšie riešenie, pri ktorom iba do hlavičky volajúcej
    metódy (v príklade nižšie ide o metódu `main`) pridáme upozornenie,
    že v nej môže vzniknúť neošetrená výnimka typu `IOException` (v
    prípade, že sme neimportovali celý balík `java.io`, je z neho
    potrebné importovať triedu `java.io.IOException`).

<!-- end list -->

``` java
public static void main(String[] args) throws IOException {
    PrintStream out = new PrintStream("vystup.txt");
    // ...
}
```

Po vytvorení výstupného prúdu môžeme používať jeho metódy na zápis do
súboru, ako napríklad nasledujúce.

  - `print`: zapíše do súboru svoj argument (prakticky ľubovoľného
    typu).
  - `println`: to isté, len s novým riadkom na konci (pri volaní bez
    argumentov vypíše iba znak pre nový riadok).
  - `format` alebo `printf`: zapíše text podľa formátovacieho reťazca
    podobného ako v C (viac
    [tu](https://docs.oracle.com/javase/tutorial/essential/io/formatting.html)).
  - `close`: metóda bez argumentu, ktorá zavrie otvorený výstupný prúd a
    je potrebné ju zavolať akonáhle so súborom prestaneme pracovať.

Kompletný program zapisujúci do súboru `vystup.txt` tak môže vyzerať
napríklad nasledovne.

``` java
import java.io.*; 

public class Trieda {

    public static void main(String[] args) throws IOException {
        PrintStream out = new PrintStream("subor.txt");
        out.print("Nejaky text");
        out.println();
        out.println("Nejaky iny text");
        out.close();
    }
}
```

Špeciálnym výstupným prúdom typu `PrintStream` je aj štandardný výstupný
prúd
[`System.out`](https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/lang/System.html#out).
Pri práci s ním tak možno používať rovnaké metódy ako vyššie. Nie je
pritom potrebné importovať triedu `PrintStream` (pretože pracujeme iba s
jej inštanciou `System.out` a trieda `System` sa importuje automaticky),
ani špecifikovať `throws IOException` (pretože nevoláme konštruktor
triedy `PrintStream`, ktorý túto výnimku môže spôsobiť). Obvykle tiež
nie je vhodné výstupný prúd `System.out` zatvárať metódou `close`, keďže
sa tým do budúcnosti používanie štandardného výstupu znemožní.

``` java
public class Trieda {

    public static void main(String[] args) {
        System.out.print("Nejaky text");
        System.out.println();
        System.out.println("Nejaky iny text");
    }
}
```

### Vstupné prúdy

Základná trieda pre vstupné prúdy je v Jave
[`InputStream`](https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/io/InputStream.html).
Tohto typu je aj štandardný vstupný prúd
[`System.in`](https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/lang/System.html#in)
pre čítanie z konzoly. Vstupné prúdy pre čítanie zo súboru sú
reprezentované triedou
[`FileInputStream`](https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/io/FileInputStream.html);
pre účely tejto prednášky možno `FileInputStream` považovať za špeciálny
prípad `InputStream`. Obe tieto triedy sú definované v balíku `java.io`.

Používanie týchto vstupných prúdov však nie je veľmi pohodlné, pretože
umožňujú iba čítanie po bytoch. Preto sa zvyknú používať nadstavbové
triedy, ktoré tieto jednoduché vstupné prúdy „obalia” a programátorovi
poskytnú aj pokročilejšie metódy na prácu so vstupom. V nasledujúcom
preskúmame dve z takýchto nadstavbových tried:
[`Scanner`](https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/util/Scanner.html)
a
[`BufferedReader`](https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/io/BufferedReader.html).

### Trieda `Scanner`

Trieda
[`Scanner`](https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/util/Scanner.html)
– definovaná v balíku `java.util`, z ktorého je nutné túto triedu
importovať – umožňuje rozkladať vstupný prúd na reťazce oddelené bielymi
znakmi, pričom kompatibilné reťazce dokáže konvertovať aj na číselné
typy. Alternatívne možno `Scanner` použiť aj na čítanie vstupu po
riadkoch.

`Scanner` možno vytvoriť na základe vstupného prúdu typu
[`InputStream`](https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/io/InputStream.html),
ktorým môže byť napríklad štandardný vstupný prúd `System.in` pre
čítanie z konzoly, alebo inštancia triedy
[`FileInputStream`](https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/io/FileInputStream.html)
pre čítanie z textového súboru; `Scanner` čítajúci zo vstupného súboru
možno vytvoriť aj priamo na základe inštancie triedy
[`File`](https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/io/File.html)
reprezentujúcej cestu k súboru. Triedy `FileInputStream` aj `File` sú
definované v balíku `java.io`, z ktorých ich je potrebné importovať. Pri
obidvoch spôsoboch vytvárania inštancie triedy `Scanner` *pre textový
súbor* môže vzniknúť výnimka typu `IOException`, ktorú je potrebné
ošetriť (napríklad cez `throws IOException` v hlavičke volajúcej
metódy). V prípade čítania z textového súboru je tiež potrebné na konci
`Scanner` zavrieť jeho metódou
\[<https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/util/Scanner.html#close>()
`close`\].

``` java
import java.util.*; // Kvoli triede Scanner

public class Trieda {
    
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        // ...
    } 
}
```

``` java
import java.io.*;   // Kvoli triede FileInputStream
import java.util.*; // Kvoli triede Scanner

public class Trieda {
    
    public static void main(String[] args) throws IOException {
        Scanner scanner = new Scanner(new FileInputStream("vstup.txt"));
        // ...
        scanner.close(); 
    }
}
```

``` java
import java.io.*;   // Kvoli triede File
import java.util.*; // Kvoli triede Scanner

public class Trieda {
    
    public static void main(String[] args) throws IOException {
        Scanner scanner = new Scanner(new File("vstup.txt"));
        // ...
        scanner.close();
    }
}
```

Inak je použitie triedy `Scanner` prakticky totožné, nech už čítame z
konzoly alebo zo súboru. Kompletný zoznam metód poskytovaných touto
triedou možno nájsť [v jej
dokumentácii](https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/util/Scanner.html).
Tu spomeňme aspoň nasledujúce metódy:

  - `next`: vráti nasledujúci reťazec oddelený od zvyšku vstupu bielymi
    znakmi; ak žiaden neexistuje, vyhodí výnimku (pri čítaní z konzoly
    sa to môže stať len pri manuálnom zadaní znaku konca súboru; v
    IntelliJ sa koniec súboru zadáva ako Ctrl+D bez ohľadu na operačný
    systém, t. j. aj pod Windowsom, avšak časť vstupu „nepotvrdená”
    klávesou `Enter` sa v takom prípade odignoruje).
  - `hasNext`: zistí, či na vstupe zostáva neprečítaný nebiely reťazec,
    ktorý by mohla vrátiť metóda `next` (pri čítaní z konzoly sa
    samozrejme vždy čaká na ďalší vstup zadaný používateľom).
  - `nextInt`: prečíta nasledujúci reťazec oddelený od zvyšku vstupu
    bielymi znakmi, pričom ale predpokladá, že ide o celé číslo a na
    výstup vráti tento reťazec už skonvertovaný na číslo; ak
    nasledujúci reťazec nebielych znakov neexistuje, alebo nie je
    korektnou reprezentáciou celého čísla, vyhodí výnimku.
  - `hasNextInt`: zistí, či na vstupe nasleduje reťazec
    interpretovateľný ako celé číslo, ktorý by mohla prečítať metóda
    `nextInt`.
  - Podobne napríklad `nextLong`, `nextDouble`, `hasNextLong`,
    `hasNextDouble`, atď.
  - `nextLine`: prečíta riadok až po jeho koniec a výsledný reťazec (bez
    prípadného `\n` na konci) vráti na výstupe.
  - `hasNextLine`: zistí, či na vstupe nasleduje ďalší riadok.

Na spracovanie jedného vstupného prúdu (napr. jeden prechod cez súbor
alebo spracovanie štandardného vstupu) by sa nikdy nemala používať viac
ako jedna inštancia triedy `Scanner`.

*Príklad 1*: nasledujúci program prečíta z konzoly prirodzené číslo `n`
a za ním `n` reťazcov oddelených bielymi znakmi, ktoré uloží do pola
`a`. Následne na konzolu vypíše tieto reťazce, každý na osobitnom
riadku, v opačnom poradí ako na vstupe.

``` java
import java.util.*;

public class Trieda {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        String[] a = new String[n];
        for (int i = 0; i <= n - 1; i++) {
            a[i] = scanner.next();
        }
        for (int i = n - 1; i >= 0; i--) {
            System.out.println(a[i]);
        }
    }
}
```

*Príklad 2*: nasledujúci program číta textový súbor `vstup.txt`
obsahujúci niekoľko čísel oddelených bielymi znakmi. Po prečítaní
celého vstupného súboru vypíše súčet týchto čísel na konzolu.

``` java
import java.io.*;
import java.util.*;

public class Trieda {

    public static void main(String[] args) throws IOException {
        int sucet = 0;
        Scanner scanner = new Scanner(new File("vstup.txt"));
        while (scanner.hasNextInt()) {
            sucet += scanner.nextInt();
        }
        scanner.close();
        System.out.println(sucet);
    }
}
```

### Trieda `BufferedReader`

Trieda
[`BufferedReader`](https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/io/BufferedReader.html)
– definovaná v balíku `java.io` – umožňuje čítať vstup po znakoch a po
riadkoch. Jej metódy spravidla vyhadzujú výnimky typu `IOException`,
ktoré je nutné ošetriť (aspoň cez `throws IOException` v hlavičke
volajúcej metódy).

  - Vytvorenie inštancie triedy `BufferedReader` pre čítanie z konzoly:

<!-- end list -->

``` java
BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
// ...
```

  - Vytvorenie inštancie triedy `BufferedReader` pre čítanie zo súboru:

<!-- end list -->

``` java
BufferedReader in = new BufferedReader(new FileReader("vstup.txt"));
// ...
in.close();
```

Trieda `BufferedReader` pritom poskytuje dve kľúčové metódy:

  - `read`: prečíta jeden znak zo vstupu a vráti ho na výstupe (v
    prípade konca súboru vráti -1); jej návratový typ je `int`.
  - `readLine`: prečíta jeden riadok zo vstupu; jej návratový typ je
    `String` (reťazec bez prípadného `\n` na konci riadku).

*Príklad 1*: nasledujúci program prečíta z konzoly jeden riadok a
následne na konzolu vypíše ten istý riadok, pričom ale malé písmená
abecedy prevedie na veľké.

``` java
import java.io.*;

public class Trieda {

    public static void main(String[] args) throws IOException {
        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
        String s = in.readLine();
        System.out.println(s.toUpperCase());
    }
}
```

*Príklad 2*: nasledujúci program prečíta textový súbor `vstup.txt` po
znakoch a jeho obsah vypíše na konzolu.

``` java
import java.io.*;

public class Trieda {

    public static void main(String[] args) throws IOException {
        BufferedReader in = new BufferedReader(new FileReader("vstup.txt"));
        int c;
        while ((c = in.read()) != -1) {
            System.out.print((char) c);
        }
        in.close();
    }
}
```

## Ďalšie užitočné štandardné triedy

  - Trieda
    [`Math`](https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/lang/Math.html)
    obsahuje množštvo statických metód realizujúcich matematické funkcie
    a operácie, napríklad:

<!-- end list -->

``` java
public class Trieda {

    public static void main(String[] args) {
        System.out.println(Math.pow(2, 0.5));
        System.out.println(Math.cos(Math.PI));
        System.out.println(Math.log(Math.E));
        System.out.println(Math.max(1, 2));
        System.out.println(Math.abs(-1));
        System.out.println(Math.toDegrees(Math.acos(Math.sqrt(3) / 2)));
        // ..
    }
}
```

  - Trieda
    [Random](https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/util/Random.html)
    reprezentuje generátor náhodných čísel. Je definovaná v balíku
    `java.util`. Napríklad nasledujúci program simuluje 10 hodov
    vyváženou hracou kockou.

<!-- end list -->

``` java
import java.util.*;

public class Trieda {

    public static void main(String[] args) {
        Random random = new Random();
        for (int i = 1; i <= 10; i++) {
            System.out.println(random.nextInt(6) + 1); // vygeneruj nahodne prirodzene cislo MENSIE ako 6 a zvys ho o 1
        }
    }
}
```

  - Trieda
    [Arrays](https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/util/Arrays.html)
    z balíka `java.util` obsahuje statické metódy na prácu s poľami;
    napr. `equals` na porovnávanie polí (a nie iba referencií), `copyOf`
    na kopírovanie polí (a nie iba referencií), `sort` na utriedenie
    poľa, `binarySearch` na binárne vyhľadávanie, atď.

